use crate::{Assembler, AssemblerError, DiagCallback, Diagnostic};
use std::cell::RefCell;
use std::fmt::{self, Display, Formatter};
use std::iter::Peekable;
use std::num::Wrapping;
use std::rc::Rc;

// Exported for the parser
type Token = (Location, TokType, Location);

// === Token types ===

#[derive(Debug, Clone)]
pub enum TokType {
    // Keywords
    Adc,
    Add,
    And,
    Bit,
    Call,
    Ccf,
    Cpl,
    Cp,
    Daa,
    Dec,
    Di,
    Ei,
    Halt,
    Inc,
    Jp,
    Jr,
    Ld,
    Ldi,
    Ldd,
    Ldio,
    Ldh,
    Nop,
    Or,
    Pop,
    Push,
    Res,
    Reti,
    Ret,
    Rlca,
    Rlc,
    Rla,
    Rl,
    Rrc,
    Rrca,
    Rra,
    Rr,
    Rst,
    Sbc,
    Scf,
    Set,
    Sla,
    Sra,
    Srl,
    Stop,
    Sub,
    Swap,
    Xor,
    Nz,
    Z,
    Nc,
    Af,
    Bc,
    De,
    Hl,
    Sp,
    Hld,
    Hli,
    A,
    B,
    C,
    D,
    E,
    H,
    L,
    Def,
    Fragment,
    Bank,
    Align,
    Round,
    Ceil,
    Floor,
    Div,
    Mul,
    Sin,
    Cos,
    Tan,
    Asin,
    Acos,
    Atan,
    Atan2,
    High,
    Low,
    Isconst,
    Strcmp,
    Strin,
    Strsub,
    Strlen,
    Strcat,
    Strupr,
    Strlwr,
    Include,
    Printt,
    Printi,
    Printv,
    Printf,
    Export,
    Xdef,
    Global,
    Ds,
    Db,
    Dw,
    Dl,
    Section,
    Purge,
    Rsreset,
    Rsset,
    Incbin,
    Charmap,
    Newcharmap,
    Setcharmap,
    Pushc,
    Popc,
    Fail,
    Warn,
    Fatal,
    Assert,
    StaticAssert,
    Macro,
    Endm,
    Shift,
    Rept,
    Endr,
    Load,
    Endl,
    If,
    Else,
    Elif,
    Endc,
    Union,
    Nextu,
    Endu,
    Wram0,
    Vram,
    Romx,
    Rom0,
    Hram,
    Wramx,
    Sram,
    Oam,
    Rb,
    Rw,
    Equ,
    Equs,
    Pushs,
    Pops,
    Pusho,
    Popo,
    Opt,

    // Punctuation
    Lparen,
    Rparen,
    Lbrack,
    Rbrack,
    Comma,
    Colon,

    // Operators
    //   Boolean
    OpNot,
    OpAnd,
    OpOr,
    //   Binary
    OpBinNot,
    OpBinAnd,
    OpBinOr,
    OpBinXor,
    //   Arithmetic
    OpAdd,
    OpSub,
    OpMul,
    OpDiv,
    OpMod,
    //   Comparison
    OpEq,
    OpNeq,
    OpLt,
    OpLte,
    OpGt,
    OpGte,

    // Values
    Num(i32),
    String(String),
    Ident(String),
    LocalIdent(String),
    Label(String),
    LocalLabel(String),

    // TODO: categorize
    Assign,
    CarriageRet,
    Newline,

    // Hack
    Dummy,
}

impl TokType {
    fn ident(name: String, is_local: bool, is_label: bool) -> Self {
        match (is_label, is_local) {
            (false, false) => TokType::Ident(name),
            (false, true) => TokType::LocalIdent(name),
            (true, false) => TokType::Label(name),
            (true, true) => TokType::LocalLabel(name),
        }
    }
}

// Include token names generated by the build script from the parser token names
include!(concat!(env!("OUT_DIR"), "/token_names.rs"));
// Include the keyword trie, generated like the above
include!(concat!(env!("OUT_DIR"), "/keywords.rs"));

// === Token location ===

#[derive(Debug, Clone)]
pub struct Location {
    parent: Option<Rc<Location>>,
    line_no: u32,
    col_no: u32,
}

impl Default for Location {
    fn default() -> Self {
        Self {
            parent: None,
            line_no: 1,
            col_no: 1,
        }
    }
}

impl Display for Location {
    fn fmt(&self, fmt: &mut Formatter) -> Result<(), fmt::Error> {
        write!(fmt, "???:{}:{}", self.line_no, self.col_no)
    }
}

#[derive(Debug)]
pub struct LocationSpan<'a> {
    begin: &'a Location,
    end: &'a Location,
}

impl<'a> LocationSpan<'a> {
    pub fn new(begin: &'a Location, end: &'a Location) -> Self {
        Self { begin, end }
    }
}

impl Display for LocationSpan<'_> {
    fn fmt(&self, fmt: &mut Formatter) -> Result<(), fmt::Error> {
        write!(
            fmt,
            "???:{}:{}-{}:{}",
            self.begin.line_no, self.begin.col_no, self.end.line_no, self.end.col_no
        )
    }
}

// === Utilities ===

#[derive(Debug)]
enum InterpType {
    Binary,
    Decimal,
    Upperhex,
    Lowerhex,
}

struct InterpFmt {
    fmt: InterpType,
}

impl InterpFmt {
    fn from_str(fmt: String) -> Result<Self, AssemblerError> {
        let mut chars = fmt.chars();
        let mut ret = Self {
            fmt: InterpType::Binary,
        };

        match chars.next() {
            Some('b') => ret.fmt = InterpType::Binary,
            Some('d') => ret.fmt = InterpType::Decimal,
            Some('X') => ret.fmt = InterpType::Upperhex,
            Some('x') => ret.fmt = InterpType::Lowerhex,
            None => {
                return Err(AssemblerError::EmptyInterpFmt);
            }
            Some(_) => {
                return Err(AssemblerError::BadInterpFmt(fmt));
            }
        }
        if let Some(_) = chars.next() {
            return Err(AssemblerError::BadInterpFmt(fmt));
        }
        Ok(ret)
    }
}

// === The lexer itself ===

pub enum State {
    Normal,
    Raw,
}

pub struct MutState {
    state: State,
    bin_digits: [char; 2],
    gfx_digits: [char; 4],
}

impl MutState {
    pub fn set_state(&mut self, state: State) {
        self.state = state;
    }
}

pub struct Lexer<'a> {
    chars: Peekable<Box<dyn Iterator<Item = char> + 'a>>,
    loc: Location,
    disable_macro_args: bool,

    state: &'a RefCell<MutState>,
    diagnose: &'a DiagCallback,
    assembler: &'a Assembler<'a>,
}

impl<'a> Lexer<'a> {
    pub fn new(
        iter: impl Iterator<Item = char> + 'a,
        state: &'a RefCell<MutState>,
        diagnose: &'a DiagCallback,
        assembler: &'a Assembler<'a>,
    ) -> Self {
        let chs = [1, 2];
        assert!(chs.len() == 2);
        Self {
            chars: (Box::new(iter) as Box<dyn Iterator<Item = char>>).peekable(),
            loc: Default::default(),
            disable_macro_args: false,

            state,
            diagnose,
            assembler,
        }
    }

    pub fn new_state() -> MutState {
        MutState {
            state: State::Normal,
            bin_digits: ['0', '1'],
            gfx_digits: ['0', '1', '2', '3'],
        }
    }

    // Some static properties

    fn starts_ident(c: char) -> bool {
        c.is_ascii_alphabetic() || c == '.' || c == '_'
    }

    fn is_ident(c: char) -> bool {
        c.is_ascii_alphanumeric() || c == '#' || c == '.' || c == '@' || c == '_'
    }

    fn is_whitespace(c: char) -> bool {
        c == ' ' || c == '\t'
    }

    // Lexer internal management

    fn peek(&mut self) -> Option<&char> {
        self.chars.peek()
    }

    fn next(&mut self) -> Option<char> {
        let c = self.chars.next();
        match c {
            Some('\n') => {
                self.loc.line_no += 1;
                self.loc.col_no = 1;
            }
            Some(_) => {
                self.loc.col_no += 1;
            }
            None => (),
        }
        c
    }

    // Lexer helpers

    fn discard_comment(&mut self) {
        self.disable_macro_args = true;
        loop {
            match self.peek() {
                Some('\r') => break,
                Some('\n') => break,
                None => break,
                _ => (),
            }
            self.next();
        }
        self.disable_macro_args = false;
    }

    fn discard_block_comment(&mut self) {
        self.disable_macro_args = true;
        loop {
            match self.next() {
                Some('*') => {
                    if let Some('/') = self.peek() {
                        self.next();
                        break;
                    }
                }
                None => unimplemented!(),
                _ => (),
            }
        }
        self.disable_macro_args = false;
    }

    fn read_num(&mut self, radix: u32, first_char: char) -> Result<i32, AssemblerError> {
        // The truncations performed by this function assume that the input radices are at most 16
        assert!(radix <= 16);

        let mut val = Wrapping(first_char.to_digit(radix).unwrap() as i32); // Truncation guaranteed (single digit)
        loop {
            let c: char;
            match self.peek() {
                Some(next) if next.is_digit(radix) => {
                    c = *next;
                    self.next();
                }
                _ => break,
            }

            match c.to_digit(radix) {
                Some(d) => val = val * Wrapping(radix as i32) + Wrapping(d as i32), // Truncation guaranteed (single digit)
                None => break,
            }
        }
        Ok(val.0)
    }

    fn read_prefixed_num(
        &mut self,
        radix: u32,
        alternative: Result<TokType, AssemblerError>,
    ) -> Result<TokType, AssemblerError> {
        match self.peek() {
            Some(&c) if c.is_digit(radix) => {
                self.next();
                Ok(TokType::Num(self.read_num(radix, c)?))
            }
            _ => alternative,
        }
    }

    fn read_prefixed_custom_num(
        &mut self,
        digits: &[char],
        alternative: Result<TokType, AssemblerError>,
    ) -> Result<TokType, AssemblerError> {
        match self.peek() {
            Some(c) if digits.contains(c) => {
                // The truncations performed by this function assume that the input radices are at most 16
                assert!(digits.len() < 16);
                let radix = Wrapping(digits.len() as i32);

                let mut c = *c;
                let mut val = Wrapping(0_i32);
                loop {
                    self.next();
                    val = val * radix
                        + Wrapping(digits.iter().position(|&ch| ch == c).unwrap() as i32);
                    match self.peek() {
                        Some(ch) if digits.contains(ch) => c = *ch,
                        _ => break,
                    }
                }
                Ok(TokType::Num(val.0))
            }
            _ => alternative,
        }
    }

    fn read_fractional(&mut self, int: i32) -> Result<i32, AssemblerError> {
        // TODO: test this
        let c = match self.peek() {
            Some(c) if c.is_ascii_digit() => c,
            _ => return Err(AssemblerError::EmptyFract),
        };

        let whole = i32::from(int as i16);
        if whole != int {
            // TODO: emit warning
            unimplemented!()
        }

        let mut frac: u32 = c.to_digit(10).unwrap();
        let mut len = 1;
        loop {
            self.next();
            match self.peek().and_then(|c| c.to_digit(10)) {
                Some(digit) => frac = frac * 10 + digit,
                None => break,
            }
            len += 1;
        }
        Ok(whole << 16 | (frac * (2u32.pow(16 - len)) / 5u32.pow(len)) as i32)
    }

    fn read_interpolation(&mut self) -> Result<String, AssemblerError> {
        let mut result = String::new();
        let mut fmt = None;

        loop {
            match self.peek() {
                Some('{') => {
                    self.next();
                    result.push_str(&self.read_interpolation()?);
                }
                None => {
                    (self.diagnose)(Diagnostic::Error(AssemblerError::UntermInterp.into()));
                    break;
                }
                Some('\r') => {
                    (self.diagnose)(Diagnostic::Error(AssemblerError::UntermInterp.into()));
                    break;
                }
                Some('\n') => {
                    (self.diagnose)(Diagnostic::Error(AssemblerError::UntermInterp.into()));
                    break;
                }
                Some('"') => {
                    (self.diagnose)(Diagnostic::Error(AssemblerError::UntermInterp.into()));
                    break;
                }
                Some('}') => {
                    self.next();
                    break;
                }
                Some(':') => {
                    self.next();
                    match fmt {
                        Some(_) => (self.diagnose)(Diagnostic::Error(
                            AssemblerError::MultipleInterpFmt.into(),
                        )),
                        None => {
                            match InterpFmt::from_str(result) {
                                Ok(f) => fmt = Some(f),
                                Err(err) => (self.diagnose)(Diagnostic::Error(err.into())),
                            };
                            result = String::new();
                        }
                    };
                }
                Some(&c) if Self::is_ident(c) => {
                    self.next();
                    result.push(c);
                }
                Some(&c) => {
                    self.next();
                    (self.diagnose)(Diagnostic::Error(
                        AssemblerError::IllegalInterpChar(c).into(),
                    ));
                }
            }
        }

        todo!();

        Ok(result)
    }

    fn read_str(&mut self) -> String {
        let mut s = String::new();

        loop {
            match self.next() {
                Some('"') => {
                    return s;
                }
                Some('\r') => {
                    (self.diagnose)(Diagnostic::Error(AssemblerError::UntermString.into()));
                    return s;
                }
                Some('\n') => {
                    (self.diagnose)(Diagnostic::Error(AssemblerError::UntermString.into()));
                    return s;
                }
                None => {
                    (self.diagnose)(Diagnostic::Error(AssemblerError::UntermString.into()));
                    return s;
                }

                Some('\\') => match self.peek() {
                    Some('\\') => s.push('\\'),
                    Some('"') => s.push('"'),
                    Some('{') => s.push('{'),
                    Some('}') => s.push('}'),
                    Some('n') => s.push('\n'),
                    Some('r') => s.push('\r'),
                    Some('t') => s.push('\t'),

                    Some(&c) if Self::begins_line_cont(c) => self.read_line_cont(),

                    None => {
                        (self.diagnose)(Diagnostic::Error(AssemblerError::IllegalEscapeEOF.into()));
                        return s;
                    }
                    Some(&c) => {
                        (self.diagnose)(Diagnostic::Error(AssemblerError::IllegalEscape(c).into()));
                        return s;
                    }
                },

                // Symbol interpolation
                Some('{') => match self.read_interpolation() {
                    Ok(result) => s.push_str(&result),
                    Err(err) => (self.diagnose)(Diagnostic::Error(err.into())),
                },

                Some(c) => s.push(c),
            }
        }
    }

    fn begins_line_cont(c: char) -> bool {
        c == ' ' || c == '\r' || c == '\n' || c == ';'
    }

    fn read_line_cont(&mut self) {
        loop {
            match self.peek() {
                Some(&c) if Self::is_whitespace(c) => {
                    self.next();
                }
                Some('\r') => {
                    self.next();
                    break;
                }
                Some('\n') => {
                    self.next();
                    break;
                }
                Some(';') => {
                    self.next();
                    self.discard_comment();
                }
                Some(&c) => {
                    (self.diagnose)(Diagnostic::Error(
                        AssemblerError::CharAfterLineCont(c).into(),
                    ));
                    return;
                }
                None => {
                    (self.diagnose)(Diagnostic::Error(AssemblerError::LineContEOF.into()));
                    return;
                }
            }
        }
    }

    fn read_escape(&mut self) -> Result<(), AssemblerError> {
        unimplemented!()
    }

    fn to_index(c: char) -> usize {
        (if c.is_ascii_lowercase() {
            c.to_ascii_uppercase()
        } else {
            c
        }) as usize
            - '#' as usize
    }

    fn read_ident(&mut self, first_char: char) -> Result<Option<TokType>, AssemblerError> {
        let mut keyword = Some(&KEYWORDS);
        let mut ident = String::new();
        let mut c = first_char;
        let mut is_local = false;
        let begun_at_bol = self.loc.col_no == 2; // `first_char` has been read before this

        loop {
            ident.push(c);
            keyword = keyword.and_then(|node| {
                node.children
                    .get(Self::to_index(c))
                    .and_then(Option::as_ref)
            });

            c = match self.peek() {
                Some(&ch) if Self::is_ident(ch) => ch,
                _ => break,
            };
            if c == '.' {
                // Nested local symbols are illegal
                if is_local {
                    break;
                }
                is_local = true;
            }
            self.next();
        }

        // TODO: expand EQUS, and return Ok(None)

        Ok(Some(
            keyword
                .and_then(|node| node.value.clone())
                .unwrap_or(TokType::ident(ident, is_local, begun_at_bol)),
        ))
    }

    // The lexer proper

    fn next_normal_tok(&mut self) -> Result<Option<Token>, AssemblerError> {
        loop {
            let begin = self.loc.clone();

            if let Some(c) = self.next() {
                let tok_type = match c {
                    // Unambiguous single-char tokens
                    '^' => TokType::OpBinXor,
                    '+' => TokType::Add,
                    '-' => TokType::Sub,
                    '~' => TokType::OpBinNot,
                    '[' => TokType::Lbrack,
                    ']' => TokType::Rbrack,
                    '(' => TokType::Lparen,
                    ')' => TokType::Rparen,
                    ',' => TokType::Comma,
                    ':' => TokType::Colon,

                    // Ambiguous 1- or 2-char tokens
                    '/' => {
                        // Either a division, or block comment
                        if let Some('*') = self.peek() {
                            self.discard_block_comment();
                            continue;
                        } else {
                            TokType::Div
                        }
                    }
                    '|' => {
                        // Either a binary or logical OR
                        if let Some('|') = self.peek() {
                            self.next();
                            TokType::Or
                        } else {
                            TokType::OpBinOr
                        }
                    }
                    '=' => {
                        // Either an assignment, or equality
                        if let Some('=') = self.peek() {
                            self.next();
                            TokType::OpEq
                        } else {
                            TokType::Assign
                        }
                    }
                    '<' => {
                        // Either LT or LTE
                        if let Some('=') = self.peek() {
                            self.next();
                            TokType::OpLte
                        } else {
                            TokType::OpLt
                        }
                    }
                    '>' => {
                        // Either GT or GTE
                        if let Some('=') = self.peek() {
                            self.next();
                            TokType::OpGte
                        } else {
                            TokType::OpGt
                        }
                    }
                    '!' => {
                        // Either a negation, or NEQ
                        if let Some('=') = self.peek() {
                            self.next();
                            TokType::OpNeq
                        } else {
                            TokType::OpNot
                        }
                    }

                    // Numbers, two of the prefixes being ambiguous (!)
                    '$' => self.read_prefixed_num(16, Err(AssemblerError::EmptyHex))?,
                    c if c.is_ascii_digit() => {
                        let val = self.read_num(10, c)?;
                        if let Some('.') = self.peek() {
                            self.next();
                            self.read_fractional(val)?;
                        }
                        TokType::Num(val)
                    }
                    '&' => self.read_prefixed_num(8, Ok(TokType::OpBinAnd)).unwrap(),
                    '%' => {
                        let digits = self.state.borrow().bin_digits;
                        self.read_prefixed_custom_num(&digits, Ok(TokType::OpMod))
                            .unwrap()
                    }
                    '`' => {
                        let digits = self.state.borrow().gfx_digits;
                        self.read_prefixed_custom_num(&digits, Err(AssemblerError::EmptyGfx))?
                    }

                    // Strings
                    '"' => TokType::String(self.read_str()),

                    // End-of-line stuff
                    '\r' => TokType::CarriageRet,
                    '\n' => TokType::Newline,

                    // Escapes
                    '\\' => {
                        self.read_escape()?;
                        continue;
                    }

                    // Comments
                    ';' => {
                        self.discard_comment();
                        continue;
                    }

                    // Discard whitespace
                    c if Self::is_whitespace(c) => {
                        continue;
                    }

                    // Identifiers, including keywords
                    c if Self::starts_ident(c) => match self.read_ident(c)? {
                        Some(tok) => tok,
                        None => continue,
                    },

                    // Catch-all
                    c => return Err(AssemblerError::GarbageChar(c)),
                };
                return Ok(Some((begin, tok_type, self.loc.clone())));
            } else {
                return Ok(None);
            }
        }
    }

    fn next_raw_tok(&mut self) -> Result<Option<Token>, AssemblerError> {
        // First, trim all leading whitespace
        loop {
            match self.peek() {
                Some(c) if Self::is_whitespace(*c) => (),
                _ => break,
            }
            self.next();
        }

        let begin = self.loc.clone();
        let mut end = None;

        let mut arg = String::new();
        let mut inside_string = false;
        let end_tok = loop {
            match self.peek() {
                Some('"') => inside_string = !inside_string,
                Some(';') if !inside_string => self.discard_comment(),
                Some(',') => break Some(TokType::Comma),
                Some('\r') => break Some(TokType::Newline),
                Some('\n') => break Some(TokType::Newline),
                None => break None,
                Some('\\') => {
                    self.next();
                    match self.next() {
                        Some(',') => {
                            end = Some(self.loc.clone());
                            arg.push(',');
                        }
                        Some(c) if Self::begins_line_cont(c) => self.read_line_cont(),
                        None => {
                            (self.diagnose)(Diagnostic::Error(
                                AssemblerError::IllegalEscapeEOF.into(),
                            ));
                            end = Some(self.loc.clone());
                            arg.push('\\');
                        }
                        Some(c) => {
                            // Append the following character as-is, without special treatment
                            end = Some(self.loc.clone());
                            arg.push('\\');
                            arg.push(c);
                        }
                    }
                }
                Some('{') => {
                    self.next();
                }
                Some(&c) => {
                    self.next();
                    if !Self::is_whitespace(c) {
                        end = Some(self.loc.clone());
                    }
                    arg.push(c);
                }
            }
        };

        if arg.len() == 0 {
            self.next();
            Ok(end_tok.map(|tok| (begin, tok, self.loc.clone())))
        } else {
            // Trim all trailing whitespace
            arg.truncate(arg.trim_end_matches(Self::is_whitespace).len());
            debug_assert_ne!(arg.len(), 0); // It should leave at least one character

            Ok(Some((begin, TokType::String(arg), end.unwrap())))
        }
    }
}

impl Iterator for Lexer<'_> {
    type Item = Result<Token, AssemblerError>;

    fn next(&mut self) -> Option<Self::Item> {
        match &self.state.borrow().state {
            State::Normal => self.next_normal_tok(),
            State::Raw => self.next_raw_tok(),
        }
        .transpose()
    }
}
